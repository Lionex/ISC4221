<html>

<head>
    <meta charset="utf-8">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel="stylesheet" href="css/main.css">
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          extensions: ["TeX/AMSmath.js", "TeX/AMSsymbol.js"]
      }
    });
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="/assets/pseudocode/pseudocode.min.css">
    <script src="/assets/pseudocode/pseudocode.min.js"></script>
    <script language="javascript" type="text/javascript" src="bower_components/MathJax/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script language="javascript" type="text/javascript" src="bower_components/p5js/lib/p5.js"></script>
    <!-- uncomment lines below to include extra p5 libraries -->
    <!--<script language="javascript" src="bower_components/p5js/lib/addons/p5.dom.js"></script>-->
    <!--<script language="javascript" src="bower_components/p5js/lib/addons/p5.sound.js"></script>-->
    <script language="javascript" type="text/javascript" src="js/priority-queue.js"></script>
    <script language="javascript" type="text/javascript" src="sketch/sketch.js"></script>
    <script language="javascript" type="text/javascript" src="sketch/astar.js"></script>
    <script language="javascript" type="text/javascript" src="sketch/dijkstra.js"></script>
    <script language="javascript" type="text/javascript" src="sketch/bfs.js"></script>
    <script language="javascript" type="text/javascript" src="js/main.js"></script>
</head>

<body>
    <main class="container">
        <header class="title">
            <h1 class="title__main">Visualizing Graph Search Methods</h1>
            <h2 class="title__sub">ISC4221 Final Project, Gwen Lofman</h2>
            <p class="title__summary">
                Graph search algorithms form key parts of many procesess, and find wide use in many contexts.  For cases where we have little information about our goal, or no easy way to estimate future costs, Dijkstra's algorithm remains the best algorithm to use, at least when we do not consider parallel or concurrent graph search methods.  However, some methods use a heuristic to estimate future costs, and additionally prioritize the search using information about how much it is likely to cost to reach the goal from the current node.  The better the heuristic, the more focused the search becomes.
            </p>
        </header>
        <article>
            <figure class="figure section--figure">
                <div class="figure-group">
                    <figure class="figure figure--interactive" id="astar">
                        <div id="sketch-astar" class="figure__sketch"></div>
                        <figcaption class="figure__caption figure__caption--bottom">
                            A* graph search.
                        </figcaption>
                    </figure>
                    <figure class="figure figure--interactive" id="dijkstra">
                        <div id="sketch-dijkstra" class="figure__sketch"></div>
                        <figcaption class="figure__caption figure__caption--bottom">
                            Dijkstra's algorithm.
                        </figcaption>
                    </figure>
                    <figure class="figure figure--interactive" id="bfs">
                        <div id="sketch-bfs" class="figure__sketch"></div>
                        <figcaption class="figure__caption figure__caption--bottom">
                            Breadth-first search.
                        </figcaption>
                    </figure>
                </div>
                <figcaption class="figure__caption figure__caption--bottom">
                    <b>Figure 1.</b> Red nodes have had their neighbors evaluated.  Green nodes are neighbors that have been encountered and had costs evaluated, or have been otherwise queued for future search.  The blue line is the current optimal path from the start to the current node in the search.  The algorithms depicted are 3 different methods for searching through a graph.
                </figcaption>
            </figure>
            <section class="section">
                <h2 class="section__title">Breadth-First Search</h2>
                <p>Breadth-first search does not prioritize nodes as it finds them, it simply adds them to a queue.</p>
                <figure id="bfs-algorithm" class="figure figure--inline figure--algorithm">
                    <pre id="bfs-code" style="display: none;">
                        \begin{algorithm}
                        \caption{Breadth-First Search}
                        \begin{algorithmic}
                        \PROCEDURE{BFS}{$Graph, start, end$}
                            \STATE $open := $\CALL{Queue}{}
                            \STATE $closed := $\CALL{Set}{}
                            \STATE $open.$\CALL{queue}{$start$}
                            \STATE $parent. := $\CALL{Map}{}
                            \WHILE {\NOT $open.$\CALL{isempty}{}}
                                \STATE current $\gets$ open.\CALL{pop}{}
                                \IF{current == end}
                                    \RETURN \CALL{path}{$parent$}
                                \ENDIF
                                \FOR{$neighbor$ in $graph.$\CALL{neighbors}{$current$}}
                                    \IF{$neighbor$ in $closed$}
                                        \STATE continue
                                    \ENDIF
                                    \IF{$neighbor$ \NOT in $open$}
                                        \STATE $open.$\CALL{queue}{$neighbor$}
                                    \ENDIF
                                    \STATE $parent[neighbor] = current$
                                \ENDFOR
                            \ENDWHILE
                        \ENDPROCEDURE
                        \end{algorithmic}
                        \end{algorithm}
                    </pre>
                    <script>
                        pseudocode.render(
                            document.getElementById("bfs-code").textContent,
                            document.getElementById("bfs-algorithm"),
                            {lineNumber: true}
                        )
                    </script>
                </figure>
            </section>
            <section class="section">
                <h2 class="section__title">Dijkstra's Algorithm</h2>
                <figure id="dijkstra-algorithm" class="figure figure--inline figure--algorithm">
                    <pre id="dijkstra-code" style="display: none;">
                        \begin{algorithm}
                        \caption{Dijkstra's Algorithm}
                        \begin{algorithmic}
                        \PROCEDURE{Dijkstra}{$graph, start, end$}
                        \STATE $open := $\CALL{PriorityQueue}{}  \COMMENT{prioritize by $g$}
                        \STATE $closed := $\CALL{Set}{}
                        \STATE $parent. := $\CALL{Map}{}
                        \STATE $start.g \gets 0$
                        \STATE $open.$\CALL{queue}{$start$}
                        \WHILE {\NOT $open.$\CALL{isempty}{}}
                            \STATE $current$ $\gets$ open.\CALL{pop}{}
                            \IF{$current$ == end}
                                \RETURN \CALL{path}{$parent$}
                            \ENDIF
                            \FOR{$neighbor$ in $graph.$\CALL{neighbors}{$current$}}
                                \IF{$neighbor$ in $closed$}
                                    \STATE continue
                                \ENDIF
                                \STATE $g \gets $\CALL{dist}{$current, neighbor$}
                                \IF{$neighbor.g > g$}
                                    \STATE $neighbor.g \gets g$
                                    \STATE $parent[neighbor] = current$
                                \ENDIF
                                \IF{$neighbor$ \NOT in $open$}
                                    \STATE $open.$\CALL{insert}{$neighbor$}
                                \ENDIF
                            \ENDFOR
                        \ENDWHILE
                        \ENDPROCEDURE
                        \end{algorithmic}
                        \end{algorithm}
                    </pre>
                    <script>
                        pseudocode.render(
                            document.getElementById("dijkstra-code").textContent,
                            document.getElementById("dijkstra-algorithm"),
                            {lineNumber: true}
                        )
                    </script>
                </figure>
            </section>
            <section class="section">
                <h2 class="section__title">A* Graph Search</h2>
                <figure id="astar-algorithm" class="figure figure--inline figure--algorithm">
                    <pre id="astar-code" style="display: none;">
                        \begin{algorithm}
                        \caption{A*}
                        \begin{algorithmic}
                        \PROCEDURE{AStar}{$graph, search, end$}
                        \STATE $open := $\CALL{PriorityQueue}{} \COMMENT{prioritize by $f$}
                        \STATE $closed := $\CALL{Set}{}
                        \STATE $parent. := $\CALL{Map}{}
                        \STATE $start.g \gets 0$
                        \STATE $open.$\CALL{queue}{$start$}
                        \WHILE {\NOT $open.$\CALL{isempty}{}}
                            \STATE $current$ $\gets$ open.\CALL{pop}{}
                            \IF{$current$ == end}
                                \RETURN \CALL{path}{$parent$}
                            \ENDIF
                            \FOR{$neighbor$ in $graph.$\CALL{neighbors}{$current$}}
                                \IF{$neighbor$ in $closed$}
                                    \STATE continue
                                \ENDIF
                                \STATE $g \gets $\CALL{dist}{$current, neighbor$}
                                \STATE $g \gets $\CALL{heuristic}{$neighbor,end$}
                                \STATE $f \gets g + h$  \COMMENT{estimate of total cost}
                                \IF{$neighbor.g > g$}
                                    \STATE $neighbor.g \gets g$
                                    \STATE $neighbor.h \gets h$
                                    \STATE $neighbor.f \gets f$
                                    \STATE $parent[neighbor] = current$
                                \ENDIF
                                \IF{$neighbor$ \NOT in $open$}
                                    \STATE $open.$\CALL{insert}{$neighborg$}
                                \ENDIF
                            \ENDFOR
                        \ENDWHILE
                        \ENDPROCEDURE
                        \end{algorithmic}
                        \end{algorithm}
                    </pre>
                    <script>
                        pseudocode.render(
                            document.getElementById("astar-code").textContent,
                            document.getElementById("astar-algorithm"),
                            {lineNumber: true}
                        )
                    </script>
                </figure>
            </section>
        </article>
    </main>
</body>

</html>
